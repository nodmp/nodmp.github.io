<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Home on Client Infra</title><link>https://clientinfra.com/</link><description>Recent content in Home on Client Infra</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 13 Dec 2023 00:00:00 +0800</lastBuildDate><atom:link href="https://clientinfra.com/index.xml" rel="self" type="application/rss+xml"/><item><title>使用 ASfP 搭建 Android Framwork 开发调试阅读环境</title><link>https://clientinfra.com/asfp-android-framwork-debug/</link><pubDate>Wed, 13 Dec 2023 00:00:00 +0800</pubDate><guid>https://clientinfra.com/asfp-android-framwork-debug/</guid><description>在之前写《写给Windows用户的AOSP构建开发环境配置指南》 这篇文章的时候，留了一个坑——写一篇文章介绍如何使用Android Studio 对 AOSP Framework 进行调试。在填坑过程中发现 Android Studio 对 Native Framework 的调试支持不好，所以想着写一个 Intellij Plugins 来实现，然后再来补这篇文章，这其中又因为各种事耽搁了。恰巧前段时间 Android 推出了 Android Studio for Platform ，尝鲜后发现仅支持 Java Framwork 调试，直到最近看邮件组已经支持了 Native Framework 调试。
ASfP(Android Studio for Platform) 是 Android 官方推出的专门为 AOSP 开发者打造的 Android Studio。ASfP 支持在一个 IDE 中进行 C++、Kotlin 和 Java 语言的编辑， 同时还支持将调试器附加到 Android 进程以调试 Java 和 C++ 代码，并集成了 Sonng 构建系统。
本篇文章将带领读者，使用 ASfP 搭建一个支持 AOSP 代码编辑和阅读，并能对 Native/Java Framwork 进行调试的环境。由于使用 Cuttlefish 虚拟机，读者可无需配备任何 Pixel 硬件，在个人电脑即可开始调试。
不论你是 Framework 工程师，还是想阅读代码的应用工程师，希望这篇文章能给你带来一点收获。</description></item><item><title>使用 AndroidX 增强 WebView 的能力</title><link>https://clientinfra.com/enhancing-webview-with-androidx/</link><pubDate>Wed, 26 Jul 2023 00:00:00 +0800</pubDate><guid>https://clientinfra.com/enhancing-webview-with-androidx/</guid><description>在应用开发过程中，为了在多个平台上保持一致的用户体验和提高开发效率，许多应用程序选择使用 H5 技术。在 Android 平台上，通常使用 WebView 组件来承载 H5 内容以供展示。
WebView 存在的问题 自 Android Lollipop 起，WebView 组件的升级已经独立于 Android 平台。然而，控制 WebView 的 API(android.webkit) 仍然与平台升级相关。这意味着应用开发者只能使用当前平台所定义的接口，而无法充分利用 WebView 的全部能力。例如: WebView.startSafeBrowsing API 在 Android 8.1 上被添加，该 Feature 由 WebView 提供，即使我们在 Android 7.0 更新 WebView 拥有了该 Feature ,由于 Android 7.0 没有 WebView.startSafeBrowsing API ，我们也没办法使用该功能。
WebView 的实现基于 Chromium 开源项目,而 Android 则基于 AOSP 项目，这两个项目有着不同的发布周期，WebView 往往一个月就可以推出下一个版本，而 Android 则需要一年的时间，对于 WebView 新增的 Feature 我们最迟需要一年才能使用。
AndroidX Webkit 的出现 为了解决上面平台能力和 WebView 不匹配的问题，我们可以独立于平台之外定义一套 WebView API ，并让它随着 WebView 的 Feature 更新 API ，这样解决了现有的问题却导入了另一个问题——如何将新定义的 WebView API 和 WebView 进行衔接。</description></item><item><title>使用 Gradle 解决 Android 模块化项目中的多语言支持</title><link>https://clientinfra.com/gradle-support-android-i18n/</link><pubDate>Thu, 29 Jun 2023 00:00:00 +0800</pubDate><guid>https://clientinfra.com/gradle-support-android-i18n/</guid><description>近年来越来越多的开发者和企业把目光聚焦于海外，寻求新的增长机会。然而对于一个“土生土长”的应用，想要在海外分一杯羹面临着诸多挑战，例如当地法律法规、网络环境、用户偏好等，其中最重要的恐怕就是&amp;quot;语言支持&amp;quot;了。据 Humans 分析统计，当一个APP被翻译成某一国家的母语后，收入会增加26%，下载量会提高120%。另外，如果一个 APP 支持英语、西语和中文三种语言，几乎能够覆盖全球50%的用户，可见语言支持的重要性。
为了支持多语言，通常需要将项目中所有的字符串资源提取，交给翻译人员，然后将翻译后的字符串资源导入到项目。而对于动辄上百个模块，轻则几十个模块的模块化项目来说，字符串资源会分布在各个模块，提取字符串资源的难度和模块的数量成正比。使用脚本扫描整个工程目录可能是最简单的方案——但对使用 MultiRepo 管理代码的工程，工程往往只依赖模块的aar，仅在开发过程中才会依赖源码，如果没有相应的基础设施，需要手动 clone 所有的模块源码，这无疑也是一件麻烦事。那么有没有一种方法，不需要繁琐的操作就可以让我们拿到对应的资源呢？
对使用 Monorepo 或者非模块的工程，处理字符串资源并不是麻烦事，所以不在本文的讨论范围。
切入点分析 对于字符串资源来说，同样一个词语，在不同的上下文中具有不同的含义，例如“好的“在聊天模块作为快捷回复用语翻译为 &amp;ldquo;Okay&amp;rdquo; ，在隐私协议界面作为接受约定翻译为 &amp;ldquo;Agreed&amp;rdquo; ，所以字符串资源所在的模块对于字符的翻译也是一个重要的辅助信息，导出时要包含所属模块信息。
而对于第三方比如 AndroidX 等库的字符串资源，有的是已翻译的，有的则没有必要翻译（内部调试页面），所以我们要在实际导出过程中排除这些字段。
结合上面两点，总结我们的需求就是：能够判断字符串资源属于哪个模块，有了这个前提我们可以很容易筛选出哪些是我们关注的模块内的资源，哪些资源我们不关心应该排除。带着这个目标，分析一下能达成此目标的切入点，从而确定最终的方案。
APK 中的 resources.arsc resources.arsc 是 Android 资源构建的产物，得益于它和资源文件、以及 R字节码文件的同时存在于 APK 中，应用开发者才能够方便的以 R.xxx.xxx 直接获取到对应的资源。resources.arsc 在这一过程中担任了资源映射的角色，负责在实际运行中映射 R.java 的引用资源 id 到实际的资源，而字符串资源也由resources.arsc 负责映射，R.string.xxx 对应的字符串可以通过查询 resources.arsc 得到。
要判断 resources.arsc 能否满足我们的需求，就需要对 resources.arsc 的定义和结构有一定的认识，resource.arsc 由 AAPT2 构建资源文件后生成，阅读AAPT2 源码是一种正统的途径，幸运的是由于Android开发工具链的完善，我们使用 Android Studio 的APK 分析器，可以更容易的查看 resources.arsc 的结构。
以 Android Studio 新建一个默认项目为例，打包后通过 Android Studio 的APK 分析器查看 resources.arsc 文件，从图中可以看到，resources.arsc 中的字符串资源没有所属模块的相关信息，并不能满足我们的需求，所以此方案不通。 AAR 文件中的 R.</description></item><item><title>使用 VScode 阅读 Android Kernel 代码并调试</title><link>https://clientinfra.com/read-android-kernel-source-code-with-vsccode/</link><pubDate>Thu, 22 Jun 2023 00:00:00 +0800</pubDate><guid>https://clientinfra.com/read-android-kernel-source-code-with-vsccode/</guid><description>在上一篇文章中介绍了如何编译并调试内核，当读者想阅读代码或者修改代码时会发现，没有任何代码提示和跳转。当调试内核的时候又发现，gdb命令太多了十分不方便,让人不禁怀念有他———IDE的日子，那是多么惬意的时光。
前置知识 语言服务器协议（Language Server Protocol/LSP） 语言服务器协议（LSP）定义了编辑器或IDE与语言服务器之间使用的协议，语言服务器提供了自动完成、跳转定义、查找引用等语言功能。
为什么要提出语言服务器协议并增加语言服务器呢？ 很久以前各IDE各自为营，例如Eclipse CDT（主要在Eclipse中提供C/C++支持）是由Java编写，如果一个使用TypeScript编写的IDE（例如：Visual Studio Code）想提供C/C++的支持就需要自己使用TypeScript重新写一套。
为了改善这样的局面，微软提出了LSP，将语言支持和编辑器之间增加一层抽象，编辑器/IDE只要实现LSP协议就拥有了复杂的语言支持功能，而对于语言服务器同样只需要关注实现LSP协议，而不限定使用何种语言。
关于更多语言服务器以及支持LSP的IDE列表，请查看微软LSP官网
“Any problem in computer science can be solved by another layer of indirection.”
Clangd Clangd是一个C++的语言服务器，他为C++语言提供了代码完成、编译错误、转到定义等功能。
下面是一个带有Clangd插件的Vs code,演示了代码完成功能： 安装 clangd 如果你本地有NDK环境,在NDK目录下已经有了clangd（/toolchains/llvm/prebuilt/linux-x86_64/bin/clangd）可以直接使用，如果想要独立安装，请查看文档
VScode安装clangd插件 可以直接在VScode中选择View-&amp;gt;Extensions打开插件管理，然后搜索&amp;quot;clangd&amp;ldquo;单击安装
官方推荐Make sure the Microsoft C/C++ extension is **not** installed这里先忽略，在稍后配置文件中禁用。
安装后需要重载窗口，Ctrl+Shift+P并输入Reload Window
compile_commands.json 为了让clangd能够理解你的源代码，clangd需要知道你的构建标志，而这些信息通常由compile_commands.json文件来记录，这个文件中记录了编译中每个源代码的编译命令，通常由编译系统自动生成。
CMAKE通过传递CMAKE_EXPORT_COMPILE_COMMANDS=1来生成compile_commands.json Bazel通过bazel-compile-commands-extractor来生成compile_commands.json 对于make编译的项目，可以通过Bear来生成compile_commands.json 在拥有compile_commands.json文件后，可以通过--compile-commands-dir选项来指定数据库地址。
VScode搭建源码阅读环境 Android Kernel生成compile_commands.json 本章的Android Kernel源码环境搭建参照上一篇文章
经过前置知识的介绍，为了让clangd了解Android Kernel，需要生成一个compile_commands.json文件，上文中介绍了Android Kernel的构建系统为bazel，所以自然想到使用bazel-compile-commands-extractor来生成compile_commands.json文件，Android官方早就想到了开发者有这样的需求，所以早就预制了一个target kernel_compile_commands并在build/kernel/kleaf/common_kernels.bzl中实现了该target。
在Android Kernel根目录直接运行tools/bazel run //common:kernel_x86_64_compile_commands就会在根目录下生成compile_commands.json。
源码导入VScode 直接使用VScode打开common目录，这时候只能简单的查看文件，并没有代码提示等功能 Ctrl+Shift+P并输入Open Workspece Settings(JSON) 并选择，VScode会在根目录下生成.</description></item><item><title>Android Kernel 编译与调试指北</title><link>https://clientinfra.com/android-kernel-build-and-debug/</link><pubDate>Wed, 14 Jun 2023 00:00:00 +0800</pubDate><guid>https://clientinfra.com/android-kernel-build-and-debug/</guid><description>上一篇文章介绍了在wsl2环境下编译AOSP并将其运行到Cuttlefish中，本篇文章依赖于上文Cuttlefish，请按照顺序食用本指北
环境 本指北基于以下代码和环境编写
OS : Ubuntu 22.04.2 LTS AOSP : master kernel : 根据编译目标决定 target ： aosp_cf_x86_64_phone-userdebug 设备 ： Cuttlefish 在前一篇文章说过，因为工具链的原因，AOSP的代码不宜太旧，自上一篇文章以来Cuttlefish的功能和文档逐步健全，足以见得google对其的投入程度，所以如果版本不一样会遇见无此参数等这样那样的问题，本文在master上测试通过。
Android Kernel Repo的源码下载 Linux Kernel是Android系统运行的基础，而Linux Kernel的源码在AOSP中并不存在，通常存在的是预构建的内核映像，如果想对内核做一些定制化的修改，就需要下载代码并构建，Linux Kernel像AOSP有各种各样的分支，并不是随便选择一个分支构建就可以正常运行。编译AOSP对应的Linux Kernel版本才能避免构建过程走很多弯路。每一个AOSP构建目标都预置了预编译的内核映像，可以从内核影像中获取相应版本的蛛丝马迹。
需要说明的是Android的内核项目同样是由repo(https://android.googlesource.com/kernel/manifest/) 管理的，其中Linux Kernel的源码存在于kernel/common(https://android.googlesource.com/kernel/common/) 目录下，其他目录是与构建相关的工具链或者脚本等，在之前旧版本Linux Kernel构建中可以直接下载kernel/common的代码使用make直接编译出内核镜像，但是随着Android GKI的推出，这套方法就行不通了。读者最好使用repo提供的编译脚本等进行构建。
下面以aosp_cf_x86_64_phone-userdebugtarget为例，讲述如何一步步找到对应的分支
查找Linux Kernel的version和commitId 从Android设置界面查找 如果你编译的系统已经成功运行到虚拟机，你可以打开Settings - About Phone - Android Version -Kernel Version 可以看到对应的Kernel信息，Linux的版本号按照major.minor.patch-build.desc的格式，通过匹配屏幕输出可以得出内核版本为6.1，从附加描述中提取g开头的连续字符可以得知对应的commitId为963667856ef1
从AOSP树中查找 如果只有一个构建目标（aosp_cf_x86_64_phone-userdebug）并没有运行成功虚拟机，可以遵循以下步骤获取。
索引到device/google/cuttlefish目录，device目录下存放了芯片和硬件厂商的相关产品配置,其中cuttlefish作为一款虚拟器，也被添加到了该目录下。 通过mgrep &amp;quot;:kernel&amp;quot;查看配置文件（该方法不是很通用，可以通过“添加新设备”了解相关知识），最后查看搜索到的配置文件,通过下图可以看到该目标链接的kernel映像文件位于kernel/prebuilts/6.1/x86_64/kernel-6.1 对该文件执行file kernel-6.1得到以下输出，同样可以得到commmitId为963667856ef1 kernel-6.1: Linux kernel x86 boot executable bzImage, version 6.1.25-android14-7-00377-g963667856ef1-ab10271074 (build-user@build-host) #1 SMP PREEMPT Tue Jun 6 23:03:20 UTC 2023, RO-rootFS, swap_dev 0X10, Normal VGA 根据分支拉取Kernel代码 通过上面的操作得到了Linux Kernel的版本和commitId，准备就绪就可以着手拉取代码了，需要注意上文获取的commitId是指https://android.</description></item><item><title>写给 Windows 用户的 AOSP 构建开发环境配置指南</title><link>https://clientinfra.com/windows-how-to-build-aosp/</link><pubDate>Fri, 13 Jan 2023 00:00:00 +0800</pubDate><guid>https://clientinfra.com/windows-how-to-build-aosp/</guid><description>因为忍受不了Ubuntu在4K下的Fractional Scaling体验,最近将开发环境切换到了Windows11，并尝试在Windows11 + WSL2上搭建AOSP编译开发环境，并获得了以下体验
成功编译AOSP 源码导入Source Insight Cuttlefish成功运行编译镜像 源码导入宿主Android Studio并能够单步调试 本文标题看起来仅将Windows系统包含在内，如果在Mac中找到WSL2的平等替代（例如：Docker），或者远程服务器替代WSL2的作用，那么本文也会受益于其他系统
Windows11提供了嵌套虚拟化技术，如果是非Windows11不能成功运行Cuttlefish虚拟机，只能获得代码编译，阅读源码的体验，读者如果无需运行Cuttlefish或者拥有Pixel系列真机，则可以使用Windows10系统
WSL2环境安装 （Windows） *CPU虚拟化是安装的前提环境，可以在任务管理器-性能-CPU查看是否显示虚拟化已启用
*wsl默认会安装到C盘，如果C盘容量不够300G,则自行查阅资料将其迁移到其他符合条件的硬盘
初次使用WSL可以使用wsl --install直接初始化默认安装Ubuntu系统,如果已经安装过其他发行版本，可以使用wsl --list --online + wsl --install -d &amp;lt;DistroName&amp;gt;选择Ubuntu发行版进行安装,安装完成后按照提示配置账号密码进入系统，如有其他问题请参阅官方文档
修改WSL内存和CPU核心 默认情况下Windows给WSL的配置并不是很高，我们可以在C:/Users//目录下创建.wslconfig文件（注意无后缀名，window可能自己添加txt后缀，请注意区分）,
[wsl2] processors=8 memory=16GB nestedVirtualization=true 上述核心数和内存大小请按照本机实际情况编写，但是按照Google要求，内存至少为16G,修改成功后在Windwos命令行执行wsl --shutdown以生效，在重启后的Ubuntu命令行执行 free -h和 cat /proc/cpuinfo| grep &amp;quot;processor&amp;quot;| wc -l分别查看内存和cpu是否符合
修改软件源 配置软件源可以让你更快的下载编译所需的工具，在Ubuntu中使用下面的命令进行软件源的更换
sudo sed -i &amp;#34;s@http://.*archive.ubuntu.com@https://mirrors.tuna.tsinghua.edu.cn@g&amp;#34; /etc/apt/sources.list sudo sed -i &amp;#34;s@http://.*security.ubuntu.com@https://mirrors.tuna.tsinghua.edu.cn@g&amp;#34; /etc/apt/sources.list 然后运行 sudo apt-get update 更新索引以生效。
AOSP编译环境搭建以及下载源码（Ubuntu） 配置环境 在Ubuntu中执行下述命令以配置搭建环境
sudo apt-get install git-core gnupg flex bison build-essential zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 libncurses5 lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z1-dev libgl1-mesa-dev libxml2-utils xsltproc unzip fontconfig 执行 sudo apt-get install repo来安装Repo工具</description></item></channel></rss>