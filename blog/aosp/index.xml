<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>AOSP on Client Infra</title><link>https://clientinfra.com/blog/aosp/</link><description>Recent content in AOSP on Client Infra</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 13 Dec 2023 00:00:00 +0800</lastBuildDate><atom:link href="https://clientinfra.com/blog/aosp/index.xml" rel="self" type="application/rss+xml"/><item><title>使用 ASfP 搭建 Android Framwork 开发调试阅读环境</title><link>https://clientinfra.com/asfp-android-framwork-debug/</link><pubDate>Wed, 13 Dec 2023 00:00:00 +0800</pubDate><guid>https://clientinfra.com/asfp-android-framwork-debug/</guid><description>在之前写《写给Windows用户的AOSP构建开发环境配置指南》 这篇文章的时候，留了一个坑——写一篇文章介绍如何使用Android Studio 对 AOSP Framework 进行调试。在填坑过程中发现 Android Studio 对 Native Framework 的调试支持不好，所以想着写一个 Intellij Plugins 来实现，然后再来补这篇文章，这其中又因为各种事耽搁了。恰巧前段时间 Android 推出了 Android Studio for Platform ，尝鲜后发现仅支持 Java Framwork 调试，直到最近看邮件组已经支持了 Native Framework 调试。
ASfP(Android Studio for Platform) 是 Android 官方推出的专门为 AOSP 开发者打造的 Android Studio。ASfP 支持在一个 IDE 中进行 C++、Kotlin 和 Java 语言的编辑， 同时还支持将调试器附加到 Android 进程以调试 Java 和 C++ 代码，并集成了 Sonng 构建系统。
本篇文章将带领读者，使用 ASfP 搭建一个支持 AOSP 代码编辑和阅读，并能对 Native/Java Framwork 进行调试的环境。由于使用 Cuttlefish 虚拟机，读者可无需配备任何 Pixel 硬件，在个人电脑即可开始调试。
不论你是 Framework 工程师，还是想阅读代码的应用工程师，希望这篇文章能给你带来一点收获。</description></item><item><title>使用 VScode 阅读 Android Kernel 代码并调试</title><link>https://clientinfra.com/read-android-kernel-source-code-with-vsccode/</link><pubDate>Thu, 22 Jun 2023 00:00:00 +0800</pubDate><guid>https://clientinfra.com/read-android-kernel-source-code-with-vsccode/</guid><description>在上一篇文章中介绍了如何编译并调试内核，当读者想阅读代码或者修改代码时会发现，没有任何代码提示和跳转。当调试内核的时候又发现，gdb命令太多了十分不方便,让人不禁怀念有他———IDE的日子，那是多么惬意的时光。
前置知识 语言服务器协议（Language Server Protocol/LSP） 语言服务器协议（LSP）定义了编辑器或IDE与语言服务器之间使用的协议，语言服务器提供了自动完成、跳转定义、查找引用等语言功能。
为什么要提出语言服务器协议并增加语言服务器呢？ 很久以前各IDE各自为营，例如Eclipse CDT（主要在Eclipse中提供C/C++支持）是由Java编写，如果一个使用TypeScript编写的IDE（例如：Visual Studio Code）想提供C/C++的支持就需要自己使用TypeScript重新写一套。
为了改善这样的局面，微软提出了LSP，将语言支持和编辑器之间增加一层抽象，编辑器/IDE只要实现LSP协议就拥有了复杂的语言支持功能，而对于语言服务器同样只需要关注实现LSP协议，而不限定使用何种语言。
关于更多语言服务器以及支持LSP的IDE列表，请查看微软LSP官网
“Any problem in computer science can be solved by another layer of indirection.”
Clangd Clangd是一个C++的语言服务器，他为C++语言提供了代码完成、编译错误、转到定义等功能。
下面是一个带有Clangd插件的Vs code,演示了代码完成功能： 安装 clangd 如果你本地有NDK环境,在NDK目录下已经有了clangd（/toolchains/llvm/prebuilt/linux-x86_64/bin/clangd）可以直接使用，如果想要独立安装，请查看文档
VScode安装clangd插件 可以直接在VScode中选择View-&amp;gt;Extensions打开插件管理，然后搜索&amp;quot;clangd&amp;ldquo;单击安装
官方推荐Make sure the Microsoft C/C++ extension is **not** installed这里先忽略，在稍后配置文件中禁用。
安装后需要重载窗口，Ctrl+Shift+P并输入Reload Window
compile_commands.json 为了让clangd能够理解你的源代码，clangd需要知道你的构建标志，而这些信息通常由compile_commands.json文件来记录，这个文件中记录了编译中每个源代码的编译命令，通常由编译系统自动生成。
CMAKE通过传递CMAKE_EXPORT_COMPILE_COMMANDS=1来生成compile_commands.json Bazel通过bazel-compile-commands-extractor来生成compile_commands.json 对于make编译的项目，可以通过Bear来生成compile_commands.json 在拥有compile_commands.json文件后，可以通过--compile-commands-dir选项来指定数据库地址。
VScode搭建源码阅读环境 Android Kernel生成compile_commands.json 本章的Android Kernel源码环境搭建参照上一篇文章
经过前置知识的介绍，为了让clangd了解Android Kernel，需要生成一个compile_commands.json文件，上文中介绍了Android Kernel的构建系统为bazel，所以自然想到使用bazel-compile-commands-extractor来生成compile_commands.json文件，Android官方早就想到了开发者有这样的需求，所以早就预制了一个target kernel_compile_commands并在build/kernel/kleaf/common_kernels.bzl中实现了该target。
在Android Kernel根目录直接运行tools/bazel run //common:kernel_x86_64_compile_commands就会在根目录下生成compile_commands.json。
源码导入VScode 直接使用VScode打开common目录，这时候只能简单的查看文件，并没有代码提示等功能 Ctrl+Shift+P并输入Open Workspece Settings(JSON) 并选择，VScode会在根目录下生成.</description></item><item><title>Android Kernel 编译与调试指北</title><link>https://clientinfra.com/android-kernel-build-and-debug/</link><pubDate>Wed, 14 Jun 2023 00:00:00 +0800</pubDate><guid>https://clientinfra.com/android-kernel-build-and-debug/</guid><description>上一篇文章介绍了在wsl2环境下编译AOSP并将其运行到Cuttlefish中，本篇文章依赖于上文Cuttlefish，请按照顺序食用本指北
环境 本指北基于以下代码和环境编写
OS : Ubuntu 22.04.2 LTS AOSP : master kernel : 根据编译目标决定 target ： aosp_cf_x86_64_phone-userdebug 设备 ： Cuttlefish 在前一篇文章说过，因为工具链的原因，AOSP的代码不宜太旧，自上一篇文章以来Cuttlefish的功能和文档逐步健全，足以见得google对其的投入程度，所以如果版本不一样会遇见无此参数等这样那样的问题，本文在master上测试通过。
Android Kernel Repo的源码下载 Linux Kernel是Android系统运行的基础，而Linux Kernel的源码在AOSP中并不存在，通常存在的是预构建的内核映像，如果想对内核做一些定制化的修改，就需要下载代码并构建，Linux Kernel像AOSP有各种各样的分支，并不是随便选择一个分支构建就可以正常运行。编译AOSP对应的Linux Kernel版本才能避免构建过程走很多弯路。每一个AOSP构建目标都预置了预编译的内核映像，可以从内核影像中获取相应版本的蛛丝马迹。
需要说明的是Android的内核项目同样是由repo(https://android.googlesource.com/kernel/manifest/) 管理的，其中Linux Kernel的源码存在于kernel/common(https://android.googlesource.com/kernel/common/) 目录下，其他目录是与构建相关的工具链或者脚本等，在之前旧版本Linux Kernel构建中可以直接下载kernel/common的代码使用make直接编译出内核镜像，但是随着Android GKI的推出，这套方法就行不通了。读者最好使用repo提供的编译脚本等进行构建。
下面以aosp_cf_x86_64_phone-userdebugtarget为例，讲述如何一步步找到对应的分支
查找Linux Kernel的version和commitId 从Android设置界面查找 如果你编译的系统已经成功运行到虚拟机，你可以打开Settings - About Phone - Android Version -Kernel Version 可以看到对应的Kernel信息，Linux的版本号按照major.minor.patch-build.desc的格式，通过匹配屏幕输出可以得出内核版本为6.1，从附加描述中提取g开头的连续字符可以得知对应的commitId为963667856ef1
从AOSP树中查找 如果只有一个构建目标（aosp_cf_x86_64_phone-userdebug）并没有运行成功虚拟机，可以遵循以下步骤获取。
索引到device/google/cuttlefish目录，device目录下存放了芯片和硬件厂商的相关产品配置,其中cuttlefish作为一款虚拟器，也被添加到了该目录下。 通过mgrep &amp;quot;:kernel&amp;quot;查看配置文件（该方法不是很通用，可以通过“添加新设备”了解相关知识），最后查看搜索到的配置文件,通过下图可以看到该目标链接的kernel映像文件位于kernel/prebuilts/6.1/x86_64/kernel-6.1 对该文件执行file kernel-6.1得到以下输出，同样可以得到commmitId为963667856ef1 kernel-6.1: Linux kernel x86 boot executable bzImage, version 6.1.25-android14-7-00377-g963667856ef1-ab10271074 (build-user@build-host) #1 SMP PREEMPT Tue Jun 6 23:03:20 UTC 2023, RO-rootFS, swap_dev 0X10, Normal VGA 根据分支拉取Kernel代码 通过上面的操作得到了Linux Kernel的版本和commitId，准备就绪就可以着手拉取代码了，需要注意上文获取的commitId是指https://android.</description></item><item><title>写给 Windows 用户的 AOSP 构建开发环境配置指南</title><link>https://clientinfra.com/windows-how-to-build-aosp/</link><pubDate>Fri, 13 Jan 2023 00:00:00 +0800</pubDate><guid>https://clientinfra.com/windows-how-to-build-aosp/</guid><description>因为忍受不了Ubuntu在4K下的Fractional Scaling体验,最近将开发环境切换到了Windows11，并尝试在Windows11 + WSL2上搭建AOSP编译开发环境，并获得了以下体验
成功编译AOSP 源码导入Source Insight Cuttlefish成功运行编译镜像 源码导入宿主Android Studio并能够单步调试 本文标题看起来仅将Windows系统包含在内，如果在Mac中找到WSL2的平等替代（例如：Docker），或者远程服务器替代WSL2的作用，那么本文也会受益于其他系统
Windows11提供了嵌套虚拟化技术，如果是非Windows11不能成功运行Cuttlefish虚拟机，只能获得代码编译，阅读源码的体验，读者如果无需运行Cuttlefish或者拥有Pixel系列真机，则可以使用Windows10系统
WSL2环境安装 （Windows） *CPU虚拟化是安装的前提环境，可以在任务管理器-性能-CPU查看是否显示虚拟化已启用
*wsl默认会安装到C盘，如果C盘容量不够300G,则自行查阅资料将其迁移到其他符合条件的硬盘
初次使用WSL可以使用wsl --install直接初始化默认安装Ubuntu系统,如果已经安装过其他发行版本，可以使用wsl --list --online + wsl --install -d &amp;lt;DistroName&amp;gt;选择Ubuntu发行版进行安装,安装完成后按照提示配置账号密码进入系统，如有其他问题请参阅官方文档
修改WSL内存和CPU核心 默认情况下Windows给WSL的配置并不是很高，我们可以在C:/Users//目录下创建.wslconfig文件（注意无后缀名，window可能自己添加txt后缀，请注意区分）,
[wsl2] processors=8 memory=16GB nestedVirtualization=true 上述核心数和内存大小请按照本机实际情况编写，但是按照Google要求，内存至少为16G,修改成功后在Windwos命令行执行wsl --shutdown以生效，在重启后的Ubuntu命令行执行 free -h和 cat /proc/cpuinfo| grep &amp;quot;processor&amp;quot;| wc -l分别查看内存和cpu是否符合
修改软件源 配置软件源可以让你更快的下载编译所需的工具，在Ubuntu中使用下面的命令进行软件源的更换
sudo sed -i &amp;#34;s@http://.*archive.ubuntu.com@https://mirrors.tuna.tsinghua.edu.cn@g&amp;#34; /etc/apt/sources.list sudo sed -i &amp;#34;s@http://.*security.ubuntu.com@https://mirrors.tuna.tsinghua.edu.cn@g&amp;#34; /etc/apt/sources.list 然后运行 sudo apt-get update 更新索引以生效。
AOSP编译环境搭建以及下载源码（Ubuntu） 配置环境 在Ubuntu中执行下述命令以配置搭建环境
sudo apt-get install git-core gnupg flex bison build-essential zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 libncurses5 lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z1-dev libgl1-mesa-dev libxml2-utils xsltproc unzip fontconfig 执行 sudo apt-get install repo来安装Repo工具</description></item></channel></rss>